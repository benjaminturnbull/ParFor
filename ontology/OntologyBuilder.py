# PARFOR Ontology Builder
#
# Reads in a TTL file and outputs a .py file of the variables
# referencing the ontology objects. 
# useful when referring to ontology onjects in code. 
#
# We stick with the capitalisation we use in ontology, rather
# than code conventions. 
# - Objects begin with a capital letter.
# - predicates do not. 
#
# REFERENCE:
#
# If you use this work, please add a reference to :
# Turnbull, B; Randhawa, Automated event and social network
# extraction from digital evidence sources with ontological
# mapping.
#
#
# LICENCE
#
# ParFor is Copyright (C) 2013 Commonwealth of Australia.
#
# ParFor is licensed under the GNU General Public License version 3
# (#GPLv3) with extensions as allowed under clause 7 of GPLv3 to clarify
# issues of indemnity and liability.
#
# See ../COPYING file for full details.
#
#

import os
import re

ONTOLOGYFILE = "ParForOntology.ttl"
OUTPUTFILE   = "Ontology.py"







def contruct_ontology (input_list, prefix_dict):

    
    retval = """\"\"\"Unclassified. 

WARNING!
Auto generated. Do not edit this file directly. 

This file was created by the TTL / Python conversion script inside the ParFor
ontology project. 

OBJECT:
Ontology object. Use dirctly in code. 

REFERENCE:

If you use this work, please add a reference to :
Turnbull, B., Randhawa, S.; Automated event and social network
extraction from digital evidence sources with ontological
mapping. 

NOTE:
There is weirdness here in that variables and classes are not capitalised
correctly. This is to keep in line with RDF standards. So for syntax 
purposes this seems correct in use, but looks terrible here. Pylint
really hates this file. 
\"\"\"


#import surf

class Ontology:
    
    nsDict = {}
"""

#    print prefix_dict
#    print "&"
    for key in prefix_dict:
#        print key
#        print prefix_dict[key]
        retval = retval +  "    "+ key + " = None\n"

    
    for key in prefix_dict:
        retval = retval +  "    class "+ key + ":\n"
        retval = retval +  "        \"\"\" \n        " + key + "\n"
        retval = retval +  "        auto generated\n"
        retval = retval +  "        \"\"\"\n\n"
        retval = retval +  "        ns = None\n"
        
        init_str = """
        def __init__(self,name):
            self.ns = name\n"""
        
        for ttl_obj in input_list:
            ttl_ns = ttl_obj[:ttl_obj.find (":")]
            ttl_obj_name = ttl_obj[ttl_obj.find (":")+1:ttl_obj.find (" ")]
            if ttl_ns == key:
                #retval = retval + ttl_ns + "---"+ ttl_obj_name +"\n"
                retval = retval + "        "+ ttl_obj_name +" = None\n"
                init_str = init_str + "            self."+ ttl_obj_name + " = self.ns + \"" + ttl_obj_name +"\"\n"

        retval = retval + init_str + "\n\n"


    retval = retval + """    def __init__(self):\n
        \"\"\"
        Initialisation
        \"\"\"
        \n"""
    for key in prefix_dict:
        retval = retval + "        self."+key + " = Ontology." + key + " ('" + prefix_dict[key]+"')\n"
        retval = retval + "        self.nsDict[\""+key+"\"] = \"" + prefix_dict[key] + "\"\n"
    
    return retval




if __name__ == "__main__":

    fil = open(ONTOLOGYFILE, "r")
    fil_text = fil.read()
    
    #fil_text = fil_text.replace ("", "")
    
#    fil_split = fil_text.split (".\n")
    fil_split = re.split('\. *\n', fil_text)


    prefix_dict = {}
    onto_list = []
   
## add in dummy
    prefix_dict["rdf"]  = ""
    fil_split.append ("rdf:type something ")
    fil_split.append ("rdf:Property something ")
    fil_split.append ("rdf:Class something ")
       
    prefix_dict["rdfs"] = ""
    fil_split.append ("rdfs:Class something ")
    fil_split.append ("rdfs:comment something ")
    fil_split.append ("rdfs:label something ")
    
    prefix_dict["xsd"]  = ""
    prefix_dict["owl"]  = ""
    
   
   
   
    
    for ind_a in fil_split:

        ind_b = ind_a.split("\n")
#        print ind_b

        ind_z = ""
        for ind_c in ind_b:
            if len(ind_c.replace("\t","").replace(" ",""))>1:
                if ind_c[0]!="#" and ind_c[0]!="\n":
                    matchObj = re.match( '@prefix (.*?):.*?<(.*)>', ind_c)

                    if matchObj:
#                        print "matchObj.group() : ", matchObj.group()
#                        print "matchObj.group(1) : ", matchObj.group(1)
#                        print "matchObj.group(2) : ", matchObj.group(2)
                        prefix_dict[matchObj.group(1)] = matchObj.group(2)
                    else:
                        ind_z = ind_z + ind_c.replace ("\t", " ")
        if len(ind_z)>2:           
            onto_list.append(ind_z)


#        print prefix_dict
#        print "___________________"
        #print onto_list
    for key in prefix_dict:
        print key + " " + prefix_dict[key]


#        print contruct_ontology (onto_list, prefix_dict)
    fil_out = open(OUTPUTFILE, "w")
    fil_out.write(contruct_ontology (onto_list, prefix_dict))
    fil_out.close()



    
